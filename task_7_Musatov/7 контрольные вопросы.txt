1. Как установить соотношение сторон окна приложения 1:2?
В GLFW можно задать размеры окна через функцию `glfwCreateWindow`. Однако это не гарантирует правильное отображение, если не учесть соотношение в проекционной матрице. Пример изменения проекта:

---

2. Почему при повороте с `Shift+F` половина изображения пропадает?
Скорее всего, происходит выход объектов за пределы объема отсечения (clipping volume). Если объект или его часть выходит за границы фруструма (в перспективной проекции) или за границы ортогонального проекционного объема, он не отрисовывается.

Проверка и возможное решение:
- Убедитесь, что параметры фруструма (`glFrustum`) или ортогональной проекции (`glOrtho`) покрывают весь объем сцены.
- Проверьте, что модель центрирована в пределах видимого пространства.
- Добавьте масштабирование или смещение центра сцены при повороте.

---

3. Почему при движении назад машина исчезает с задней части?
Это связано с плоскостью ближнего отсечения (near clipping plane) в проекции. При движении назад машина приближается к камере, и части объекта пересекают ближнюю плоскость отсечения, что приводит к их исчезновению.

Решение:
- Увеличьте расстояние до ближней плоскости отсечения. Например:
  ```cpp
  glm::mat4 projection = glm::perspective(glm::radians(45.0f), aspect_ratio, 0.1f, 100.0f);
  ```
  Здесь `0.1f` — расстояние до ближней плоскости. Увеличьте его до значения, подходящего для сцены.

---

4. Какое предназначение библиотеки GLFW?
GLFW — это библиотека для работы с окнами, создания контекста OpenGL, обработки ввода от пользователя (клавиатура, мышь) и управления событиями.

Основные возможности:
- Создание окна с контекстом OpenGL.
- Управление контекстом (настройка и переключение).
- Обработка событий ввода (например, клавиши, мышь).
- Работа с таймингами и синхронизацией кадров.

---

5. Все используемые функции и процедуры библиотеки GLFW:
Примеры функций GLFW в типичном проекте:
- Инициализация: `glfwInit`, `glfwTerminate`.
- Создание окна: `glfwCreateWindow`, `glfwMakeContextCurrent`, `glfwWindowShouldClose`, `glfwSetWindowSize`.
- Обработка событий: `glfwPollEvents`, `glfwSetKeyCallback`.
- Синхронизация кадров: `glfwSwapBuffers`.

---

6. Где обрабатывается нажатие клавиш?
Обработка клавиш обычно задается через функцию обратного вызова, например:

```cpp
void key_callback(GLFWwindow* window, int key, int scancode, int action, int mods) {
    if (key == GLFW_KEY_ESCAPE && action == GLFW_PRESS)
        glfwSetWindowShouldClose(window, true);
    if (key == GLFW_KEY_S && action == GLFW_PRESS) {
        // Логика для движения назад
    }
}

int main() {
    glfwSetKeyCallback(window, key_callback);
}
```

---

7. Какое предназначение библиотеки GLM?
GLM (OpenGL Mathematics) — это библиотека для работы с математикой, необходимой в графике:
- Векторы, матрицы, преобразования.
- Создание матриц проекции (`glm::perspective`, `glm::ortho`).
- Работа с преобразованиями объектов (повороты, масштабирование, перемещения).

---

8. Что произойдет, если первые два аргумента `glViewport` задать отличными от нуля?
glViewport(x, y, width, height) задает область отрисовки. Если x и y отличны от нуля, область отрисовки будет смещена от левого нижнего угла окна. Это может привести к тому, что часть изображения будет обрезана или смещена.

Пример:
```cpp
glViewport(100, 50, 400, 300);
```
Область отрисовки начнется на 100 пикселей вправо и 50 вниз.

---

9. Что произойдет, если `glfwSwapBuffers` перенести в конец внешнего цикла `for`?
Если `glfwSwapBuffers` вызывается не в каждом кадре, обновление окна происходит реже. Это вызовет мерцание или лаг в отображении графики.

---

10. Все используемые функции и процедуры библиотеки GLM:
- Матрицы проекции: `glm::perspective`, `glm::ortho`.
- Матрицы преобразования: `glm::translate`, `glm::rotate`, `glm::scale`.
- Операции с векторами и матрицами: `glm::vec3`, `glm::mat4`, `glm::normalize`.

---

11. Что такое C?
- Вершинный массив (VAO): хранит состояние атрибутов вершин.
- Вершинный буфер (VBO): хранит сами данные вершин (позиции, нормали, текстурные координаты).

Создание:
1. Создать VBO: 
   ```cpp
   GLuint VBO;
   glGenBuffers(1, &VBO);
   glBindBuffer(GL_ARRAY_BUFFER, VBO);
   glBufferData(GL_ARRAY_BUFFER, sizeof(vertices), vertices, GL_STATIC_DRAW);
   ```
2. Создать VAO:
   ```cpp
   GLuint VAO;
   glGenVertexArrays(1, &VAO);
   glBindVertexArray(VAO);
   glVertexAttribPointer(...);
   glEnableVertexAttribArray(...);
   ```

---

12. Почему шейдеры описываются в виде строки?
OpenGL принимает шейдерный код на GLSL в виде строки. Это необходимо, чтобы компилировать шейдеры во время выполнения программы.

Шейдеры передаются в GPU в виде текстового кода, который компилируется драйвером во время выполнения программы.

---

13. Что такое шейдерная программа?
Шейдерная программа — это связка скомпилированных шейдеров (вершинного, фрагментного), которую OpenGL использует для рендеринга.

Шейдерная программа — комбинация шейдеров используемая для некоторого набора данных. В эту комбинацию
обязательно входит один вершинный шейдер, один фрагментный шейдер. Возможно присутствие по одному экземпляру шейдера каждого другого вида.

---

14. Как передаются вершинные данные в GPU?
Пример передачи данных:
```cpp
glBindBuffer(GL_ARRAY_BUFFER, VBO);
glBufferData(GL_ARRAY_BUFFER, sizeof(vertices), vertices, GL_STATIC_DRAW);
```

---

15. Что такое uniform-переменная? Как ей присвоить значение?
Uniform — это глобальная переменная шейдера, задаваемая из CPU. Пример:
```cpp
GLuint location = glGetUniformLocation(program, "uniformName");
glUniformMatrix4fv(location, 1, GL_FALSE, glm::value_ptr(matrix));

```

---

16. Почему в проекте осталось только два вложенных цикла?
Для организации 3D-сцены используется матрица, а не вложенные циклы. Это упрощает логику.

Скорее всего, часть цикла перенесена в шейдер для повышения производительности. Например, вычисления для осей или точек теперь выполняются на GPU.